from collections import defaultdict

try:
    import networkx as nx
except NameError:
    nx = None


if nx:
    def tasks_as_networkx_graph(task_ctrl):
        assert task_ctrl.finalized
        G = nx.DiGraph()
        for task in task_ctrl.tasks:
            G.add_node(task)

            for prev_task in task_ctrl.prev_tasks[task]:
                G.add_edge(prev_task, task)
        return G

    def files_as_networkx_graph(task_ctrl):
        assert task_ctrl.finalized
        G = nx.DiGraph()
        for task in task_ctrl.tasks:
            for i in task.inputs:
                for o in task.outputs:
                    G.add_edge(i, o)
        return G


class TaskControl:
    def __init__(self):
        self.tasks = []

        self.finalized = False

        # Get added to as new tasks are added.
        self.output_task_map = {}
        self.input_task_map = defaultdict(list)
        self.task_from_hexdigest = {}

        # Generated by self.finalize()
        self.input_paths = set()
        self.output_paths = set()
        self.input_tasks = set()

        self.prev_tasks = defaultdict(list)
        self.next_tasks = defaultdict(list)

        self.sorted_tasks = []

        self.completed_tasks = []
        self.pending_tasks = []
        self.running_tasks = []
        self.remaining_tasks = set()

        self._dag_built = False

    def add(self, task):
        if self.finalized:
            raise Exception(f'TaskControl already finilized')

        for output in task.outputs:
            if output in self.output_task_map:
                raise Exception(f'Trying to add {output} twice')
        hexdigest = task.hexdigest()
        if hexdigest in self.task_from_hexdigest:
            raise Exception(f'Trying to add {task} twice')
        self.task_from_hexdigest[hexdigest] = task

        self.tasks.append(task)
        for input_path in task.inputs:
            self.input_task_map[input_path].append(task)
        for output in task.outputs:
            self.output_task_map[output] = task

        return task

    def _topogological_tasks(self):
        assert self._dag_built

        curr_tasks = set(self.input_tasks)
        all_tasks = set()
        while True:
            next_tasks = set()
            for curr_task in curr_tasks:
                can_yield = True
                for prev_task in self.prev_tasks[curr_task]:
                    if prev_task not in all_tasks:
                        can_yield = False
                        break
                if can_yield and curr_task not in all_tasks:
                    yield curr_task
                    all_tasks.add(curr_task)

                for next_task in self.next_tasks[curr_task]:
                    next_tasks.add(next_task)
            if not next_tasks:
                break
            curr_tasks = next_tasks

    def finalize(self):
        assert not self.finalized

        # Work out whether it is possible to create a run schedule and find initial tasks.
        # Fill in self.prev_tasks and self.next_tasks; these hold the information about the
        # task DAG.
        for task in self.tasks:
            is_input_task = True
            for input_path in task.inputs:
                if input_path in self.output_task_map:
                    is_input_task = False
                    # Every output is created by only one task.
                    input_task = self.output_task_map[input_path]
                    if input_task not in self.prev_tasks[task]:
                        self.prev_tasks[task].append(input_task)
                else:
                    # input_path is not going to be created by any tasks; it might still exist though:
                    if not input_path.exists():
                        raise Exception(f'No input file {input_path} exists or will be created for {task}')
                    self.input_paths.add(input_path)
            if is_input_task:
                self.input_tasks.add(task)

            for output_path in task.outputs:
                if output_path in self.input_task_map:
                    # Each input can be used by any number of tasks.
                    output_tasks = self.input_task_map[output_path]
                    for output_task in output_tasks:
                        if output_task not in self.next_tasks[task]:
                            self.next_tasks[task].extend(output_tasks)

        self._dag_built = True

        # Can now perform a topological sort.
        self.sorted_tasks = list(self._topogological_tasks())
        assert len(self.sorted_tasks) == len(self.tasks)
        assert set(self.sorted_tasks) == set(self.tasks)

        # import ipdb; ipdb.set_trace()
        # Assign each task to one of three groups:
        # completed: task has been run and does not need to be rerun.
        # pending: task has been run and needs to be rerun.
        # remaining: task either needs to be rerun, or has previous tasks that need to be rerun.
        for task in self.sorted_tasks:
            task_state = 'completed'
            if task.can_run() and task.requires_rerun():
                task_state = 'pending'
                for prev_task in self.prev_tasks[task]:
                    if prev_task in self.pending_tasks or prev_task in self.remaining_tasks:
                        task_state = 'remaining'
                        break
            else:
                for prev_task in self.prev_tasks[task]:
                    if prev_task in self.pending_tasks or prev_task in self.remaining_tasks:
                        task_state = 'remaining'
                        break

            if task_state == 'completed':
                self.completed_tasks.append(task)
            elif task_state == 'pending':
                self.pending_tasks.append(task)
            elif task_state == 'remaining':
                self.remaining_tasks.add(task)

        all_tasks_assigned = (set(self.completed_tasks) | set(self.pending_tasks) | set(self.remaining_tasks) == set(self.tasks) and
                              len(self.completed_tasks) + len(self.pending_tasks) + len(self.remaining_tasks) == len(self.tasks))
        assert all_tasks_assigned, 'All tasks not assigned.'

        self.output_paths = set(self.output_task_map.keys()) - self.input_paths

        self.finalized = True
        return self

    def get_next_pending(self):
        while self.pending_tasks or self.running_tasks:
            if not self.pending_tasks:
                yield None
            else:
                task = self.pending_tasks.pop(0)
                self.running_tasks.append(task)
                yield task

    def task_complete(self, task):
        assert task in self.running_tasks, 'task not being run'
        assert task.complete(), 'task not complete'
        self.running_tasks.remove(task)
        self.completed_tasks.append(task)

        for next_task in self.next_tasks[task]:
            requires_rerun = True
            # Make sure all previous tasks have been run.
            for prev_tasks in self.prev_tasks[next_task]:
                if prev_tasks not in self.completed_tasks:
                    requires_rerun = False
                    break
            # According to precalculated values next task requires rerun.
            # What does next task think?
            if requires_rerun and next_task.requires_rerun():
                self.pending_tasks.append(next_task)
                self.remaining_tasks.remove(next_task)

    def run(self, force=False):
        assert self.finalized

        for task in self.get_next_pending():
            if task is None:
                raise Exception()
            task_run_index = len(self.completed_tasks) + len(self.running_tasks)
            print(f'{task_run_index}/{len(self.tasks)}: {repr(task)}')
            task.run(force=force)
            self.task_complete(task)

    def run_one(self, force=False):
        assert self.finalized

        task = next(self.get_next_pending())
        if task is None:
            raise Exception()

        task_run_index = len(self.completed_tasks) + len(self.running_tasks)
        print(f'{task_run_index}/{len(self.tasks)}: {repr(task)}')
        task.run(force=force)
        self.task_complete(task)

